// go-wasm.ts - Generated by gowasm-bindgen
// Package: main

export class GoWasm {
  private worker: Worker;
  private requestId = 0;
  private pending = new Map<
    number,
    { resolve: (v: unknown) => void; reject: (e: Error) => void }
  >();
  private nextCallbackId = 0;
  private callbacks = new Map<number, (...args: unknown[]) => void>();

  private constructor(worker: Worker) {
    this.worker = worker;
  }

  static async init(workerUrl: string): Promise<GoWasm> {
    const worker = new Worker(workerUrl);
    const instance = new GoWasm(worker);

    await new Promise<void>((resolve, reject) => {
      worker.onmessage = (event) => {
        const { type, id, result, error, callbackId, args } = event.data;
        if (type === 'ready') {
          resolve();
          return;
        }
        // Handle callback invocations from Go
        if (type === 'invokeCallback') {
          const callback = instance.callbacks.get(callbackId);
          if (callback) {
            try {
              callback(...args);
            } catch (e) {
              console.error('Callback error:', e);
            }
          }
          return;
        }
        const handler = instance.pending.get(id);
        if (handler) {
          instance.pending.delete(id);
          if (error) {
            handler.reject(new Error(error));
          } else if (
            result &&
            typeof result === 'object' &&
            '__error' in result
          ) {
            handler.reject(new Error((result as { __error: string }).__error));
          } else {
            handler.resolve(result);
          }
        }
      };
      worker.onerror = (e) =>
        reject(new Error(e.message || 'Worker failed to load'));
    });

    return instance;
  }

  terminate(): void {
    this.worker.terminate();
  }

  private call<T>(fn: string, args: unknown[]): Promise<T> {
    return new Promise((resolve, reject) => {
      const id = ++this.requestId;
      this.pending.set(id, {
        resolve: resolve as (v: unknown) => void,
        reject,
      });
      this.worker.postMessage({ id, fn, args });
    });
  }

  private registerCallback(fn: (...args: unknown[]) => void): number {
    const id = ++this.nextCallbackId;
    this.callbacks.set(id, fn);
    return id;
  }

  /**
   * Greet returns a greeting message.
   * Simple example showing basic string input/output.
   */
  greet(name: string): Promise<string> {
    return this.call<string>('greet', [name]);
  }

  /**
   * Fibonacci calculates the Nth Fibonacci number with arbitrary precision.
   * Demonstrates: callbacks, large computations, returning data JS can't compute.
   */
  fibonacci(
    n: number,
    onProgress: (arg0: number, arg1: string) => void
  ): Promise<string> {
    const onProgressId = this.registerCallback(
      onProgress as (...args: unknown[]) => void
    );
    return this.call<string>('fibonacci', [n, onProgressId]).finally(() => {
      this.callbacks.delete(onProgressId);
    });
  }
}
